using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TreeGen : MonoBehaviour
{
    // 3 branches, TreeBranchA,B,C, each have 6 loops, LoopA though F, and a LoopTop. Each loop has 6 points 1 though 6

    //TODO:
    /*Spawn 1 of the 3 branches as the origin point. From here it will generate a tree. By default there will be 3 architypes avalible, a pine tree, a generic fruit tree (options between apple, orange, and lemon) , and an oak tree
     The trees will be generated by choosing which loops to generate branches from, how many nodes in the loop will generate branches, and how many recursive times the branches will generate.
     For Example: An apple tree would use the upper half of the root tree to generate branches, and will randomly generate recursive branches so that there are a lot of random wild branches everywhere
     A pine tree would most likely use all loops, generating on a few of the loop nodes, and with few recursive branches with those generating flat and not vertical. It could also have the behavior of bigger branches at the bottom and smaller at the top
     An oak would be simillar to a fruit tree but would probably have the revursive branches start off large and slowly fall off in size as the split

        Overall for trees, the loops would be used a lot for initial generation, and the top loop would be used for recursive branches since in real life trees dont randomly spawn new branches off the side but instead split at the top (so it seems)
         */

    public int treetype;
    //2 TreeGen objects used to create the current treegen
    public GameObject parentA;
    public GameObject parentB;
    //The three premade branches (Used so that mesh generation doesnt have to be done on the fly)
    public GameObject treeBranchA;
    public GameObject treeBranchB;
    public GameObject treeBranchC;
    //Types of leafs a tree can have
    public GameObject leafA;
    public GameObject leafB;
    public GameObject leafC;
    //Types of fruit a tree can have
    public GameObject fruitA;
    public GameObject fruitB;
    public GameObject fruitC;
    //Tree colors
    public Material colorA;
    public Material colorB;
    private Material chosenColor;
    //Used to determine which loops will have branches spawn on. The number of each point in the array determines the number of points in the loop will have branches (point 0 is the bottom, 5 the top ring, and 6 the top split)
    public int[] branchDist = new int[7];
    //Used to determine which loops will have (recursive) branches spawn on. The number of each point in the array determines the number of points in the loop will have (recursive) branches
    public int[] branchDistRec = new int[7];
    //The number of times it will recursively create child branches
    public int depth;
    //How small a (recursive) branch will be compared to its parent 
    //The equation is 
    //sin((.5(currentDepth - 1))^1/branchSizeLoss)+1
    //-----------------------------------------------
    //                        2
    //
    public float branchSizeLoss;
    //If a tree has a trianglar shape this is used to get that effect
    public float verticalBranchSizeLoss = 0;

    private GameObject parent = null;
    // Start is called before the first frame update
    void Start()
    {
        branchDist = new int[] { 0, 0, 0, 0, 0, 0, 0 };
        branchDistRec = new int[] { 0, 0, 0, 0, 0, 0, 0 };
        var branch = branchChooser();
        branch = Instantiate(branch, transform);
        branch.AddComponent<Parent>();
        branch.GetComponent<Parent>().parent = this.gameObject;
        //Only makes new stats if it is a new tree origin
        if (parent == null)
        {
            //Sets the stats for the tree
            if(parentA != null && parentB != null)
            {
                TreeGen thingyA = parentA.GetComponent<TreeGen>();
                TreeGen thingyB = parentB.GetComponent<TreeGen>();

                var aDist = thingyA.getbranchDist();
                var aRecDist =  thingyA.getbranchDistRec();
                var aDepth = thingyA.depthGet();
                var aSizeLoss = thingyA.getSizeLoss();
                var aVertSizeLoss = thingyA.getVertSizeLoss();
                var aChosenColor = thingyA.getChosenColor();

                var bDist = thingyB.getbranchDist();
                var bRecDist = thingyB.getbranchDistRec();
                var bDepth = thingyB.depthGet();
                var bSizeLoss = thingyB.getSizeLoss();
                var bVertSizeLoss = thingyB.getVertSizeLoss();
                var bChosenColor = thingyB.getChosenColor();

                
                for (int i = 0; i < aDist.Length; i++)
                {
                    var valueA = aDist[i];
                    var valueB = bDist[i];
                    var minValue = Mathf.Min(valueA, valueB);
                    var maxValue = Mathf.Max(valueA, valueB) + 1;
                    
                    if (minValue > 0) minValue = minValue - 1;
                    branchDist.SetValue(Random.Range(minValue, maxValue + 1), i);
                    

                    valueA = aRecDist[i];
                    valueB = bRecDist[i];
                    minValue = Mathf.Min(valueA, valueB);
                    maxValue = Mathf.Max(valueA, valueB) + 1;
                    branchDistRec.SetValue(Random.Range(minValue, maxValue + 1), i);
                }
                depth = Random.Range(Mathf.Min(aDepth, bDepth) - 1, Mathf.Max(aDepth, bDepth) + 2);
                branchSizeLoss = Random.Range(Mathf.Min(aSizeLoss, bSizeLoss) - 0.3f, Mathf.Max(aSizeLoss, bSizeLoss) + 0.3f);
                verticalBranchSizeLoss = Random.Range(Mathf.Min(aVertSizeLoss, bVertSizeLoss) - 0.3f, Mathf.Max(aVertSizeLoss, bVertSizeLoss) + 0.3f);
                if (Random.Range(0f, 1f) > 0.5f) chosenColor = aChosenColor; else chosenColor = bChosenColor;
            }
            
            else
            {
                switch (Random.Range(0, 3))
                {
                    case 0:
                        oakTree();
                        break;
                    case 1:
                        spruceTree();
                        break;
                    case 2:
                        birchTree();
                        break;
                    default:
                        oakTree();
                        break;
                }
            }
            branch.GetComponent<Renderer>().material = chosenColor;

        }
        treeAssembler(branch, 0);
        
    }


    private void treeAssembler(GameObject parent, int currentDepth)
    {
        if (currentDepth == 0)
        {

            //Which loop are we currently on
            for (int i = 0; i < branchDist.Length; i++)
            {

                int randomFactor = Random.Range(0, 3);
                //the # of branches that will spawn. Each loop spawns a new branch
                for (int j = 0; j < branchDist[i]; j++)
                {
                    //Picks where a branch will spawn. (evenly distributes branch spawns among spawn points 
                    int spawnPoint = (int)(6 / branchDist[i]) * (j+1) - 1;
                    spawnPoint = randomizer(randomFactor, spawnPoint);

                    var branch = branchChooser();
                    GameObject currentNode = parent.transform.GetChild(0).gameObject;
                    currentNode = currentNode.transform.GetChild(i).gameObject;
                    currentNode = currentNode.transform.GetChild(spawnPoint).gameObject;


                    branch = Instantiate(branch, currentNode.transform);
                    branch.GetComponent<Renderer>().material = chosenColor;
                    branch.AddComponent<Parent>();
                    branch.GetComponent<Parent>().parent = this.gameObject;
                    branch.transform.rotation = currentNode.transform.rotation;
                    branch.transform.localScale = parent.transform.localScale * ((Mathf.Sin(.5f * Mathf.Pow(currentDepth, 1/branchSizeLoss)) + 1f)/ 2);
                    if (currentDepth < depth)
                    {
                        treeAssembler(branch, currentDepth + 1);
                    }
                }
            }
        } else
        {
            //Which loop are we currently on
            for (int i = 0; i < branchDistRec.Length; i++)
            {
                int randomFactor = Random.Range(0, 3);

                //the # of branches that will spawn. Each loop spawns a new branch
                for (int j = 0; j < branchDistRec[i]; j++)
                {
                    //Picks where a branch will spawn. (evenly distributes branch spawns among spawn points 
                    int spawnPoint = (int)(6 / branchDistRec[i]) * (j+1) - 1;
                    spawnPoint = randomizer(randomFactor, spawnPoint);

                    var branch = branchChooser();
                    GameObject currentNode = parent.transform.GetChild(0).gameObject;
                    currentNode = currentNode.transform.GetChild(i).gameObject;
                    currentNode = currentNode.transform.GetChild(spawnPoint).gameObject;


                    branch = Instantiate(branch, currentNode.transform);
                    branch.AddComponent<Parent>();
                    branch.GetComponent<Parent>().parent = parent;
                    branch.transform.rotation = currentNode.transform.rotation;
                    branch.transform.localScale = parent.transform.localScale * ((Mathf.Sin(.5f * Mathf.Pow(currentDepth, 1 / branchSizeLoss)) + 1f) / 2);
                    if (currentDepth < depth)
                    {
                        treeAssembler(branch, currentDepth + 1);
                    }
                }
            }
        }
        
    }

    private int randomizer(int randomfactor, int spawnpoint)
    {
        return (spawnpoint + randomfactor) % 6;
    }

    private GameObject branchChooser()
    {
        switch (Random.Range(0, 3))
        {
            case 0:
                return treeBranchA;
            case 1:
                return treeBranchB;
            case 2:
                return treeBranchC;
            default:
                return treeBranchA;
        }
    }

    private void oakTree()
    {
        branchDist = new int[] { 0, 0, 0, 0, 2, 0, 2 };
        branchDistRec = new int[] { 0, 0, 0, 0, 0, 0, 4 };
        depth = 4;
        branchSizeLoss = 0.5f;
        verticalBranchSizeLoss = 0.5f;
        chosenColor = colorB;
    }

    private void spruceTree()
    {
        
        branchDist = new int[] { 0, Random.Range(2, 4), 0, Random.Range(2, 4), 0, Random.Range(2, 4), 0 };
        branchDistRec = new int[] { 0, Random.Range(1, 3), 0, Random.Range(1, 3), 0, Random.Range(1, 3), 0 };
        depth = 2;
        branchSizeLoss = 1f;
        verticalBranchSizeLoss = 1/6f;
        chosenColor = colorB;
    }

    private void birchTree()
    {
        branchDist = new int[] { 0, 0, 0, 0, 0, 0, Random.Range(2, 6)};
        branchDistRec = new int[] { 0, 0, 0, 0, 0, 0, Random.Range(1, 3) };
        depth = 3;
        branchSizeLoss = .8f;
        verticalBranchSizeLoss = .5f;
        chosenColor = colorA;

    }

    public int[] getbranchDist()
    {
        return branchDist;
    }

    public int[] getbranchDistRec()
    {
        return branchDistRec;
    }

    public int depthGet()
    {
        return depth;
    }

    public float getSizeLoss()
    {
        return branchSizeLoss;
    }

    public float getVertSizeLoss()
    {
        return verticalBranchSizeLoss;
    }

    public Material getChosenColor()
    {
        return chosenColor;
    }
}
